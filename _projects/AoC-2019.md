---
layout: project
title: Advent of Code - 2019
description: A challenge to complete 25 algorithmic problems, one a day during the lead up to Christmas
thumbnail: /projects/thumbnails/aoc-2019.png
repo: https://gitlab.com/TateKennington/aoc-2019
---
The Advent of Code is a yearly event where people compete to solve 25 algorithmic problems during the lead up to Christmas. Below are a brief description of each problem I solved and my analysis and solution for that problem.

<h2>Day 1</h2>

{% highlight go %}
func main(){
	var x = 0;
	var ans = 0;
	for{
		n, _ := fmt.Scanf("%d\n", &x);
		
		if n==0{
			break;
		}

		for x/3-2 > 0{
			ans+=x/3-2;
			x = x/3-2;
		}
	}
	fmt.Println(ans);
}
{% endhighlight %}

<h2>Day 2</h2>
Day 2 on itself was not too difficult of a problem, however, it did setup for me to be brought low when the intcode computer returned on Day 5.

{% highlight go %}
func main(){
	var scanner = bufio.NewScanner(os.Stdin);
	scanner.Scan();
	done := false;
	for noun:=0; noun<99 && !done; noun++{
		for verb:=0; verb<99 && !done; verb++{
			var input = scanner.Text();
			var codesText = strings.Split(input, ",");
			var codes []int;
			for _, code := range codesText {
				x,  _ := strconv.Atoi(code);
				codes = append(codes, x);
			}
			codes[1] = noun;
			codes[2] = verb;
			for curr:=0; curr<len(codes); curr+=4{
				switch(codes[curr]){
					case 99:
						break;
					case 1:
						codes[codes[curr+3]] = codes[codes[curr+1]] + codes[codes[curr+2]];
					case 2:
						codes[codes[curr+3]] = codes[codes[curr+1]] * codes[codes[curr+2]];
				}
			}
			if codes[0] == 19690720{
				fmt.Println(noun*100+verb);
				done = true;
			}
		}
	}
}
{% endhighlight %}

<h2>Day 3</h2>

{% highlight go %}
func main(){
	var kb = bufio.NewScanner(os.Stdin);
	var points = make(map[[2]int]int);
	var curr = [2]int{0,0};
	var step = [2]int{0,0};
	var count = 0;
	var ans = -1;
	var wire1 string;
	var wire2 string;

	kb.Scan();
	wire1 = kb.Text();
	kb.Scan();
	wire2 = kb.Text();

	for _, x := range strings.Split(wire1, ","){
		dist, _ := strconv.Atoi(x[1:]);

		switch(x[0]){
			case 'R':
				step[0] = 1;
				step[1] = 0;
			case 'L':
				step[0] = -1;
				step[1] = 0;
			case 'U':
				step[0] = 0;
				step[1] = 1;
			case 'D':
				step[0] = 0;
				step[1] = -1;
		}

		for i:=0; i<dist; i++{
			count++;
			curr[0]+=step[0];
			curr[1]+=step[1];
			points[curr] = count;
		}
	}

	curr = [2]int{0,0};
	count = 0;
	for _, x := range strings.Split(wire2, ","){
		dist, _ := strconv.Atoi(x[1:]);

		switch(x[0]){
			case 'R':
				step[0] = 1;
				step[1] = 0;
			case 'L':
				step[0] = -1;
				step[1] = 0;
			case 'U':
				step[0] = 0;
				step[1] = 1;
			case 'D':
				step[0] = 0;
				step[1] = -1;
		}

		for i:=0; i<dist; i++{
			count++;
			curr[0]+=step[0];
			curr[1]+=step[1];
			if temp, ok := points[curr]; ok{
				if ans == -1 || temp + count < ans {
					ans = temp+count;
				}
			}
		}
	}
	fmt.Println(ans);
}
{% endhighlight %}

<h2>Day 4</h2>
Today's was a stark change of pace, being relatively short and simple compared to the 3 days previous.

{% highlight go %}
const LOWER = 246540;
const UPPER = 787419;

func isValid(n int) bool{
	var adj = false;
	var prev = 10;
	for n > 0{
		curr := n%10;
		next := (n/10)%10;
		count := 1;
		for n > 0 && curr == next{
			count++;
			n/=10;
			curr = n%10;
			next = (n/10)%10;
		}
		if count == 2{
			adj = true;
		}
		if curr > prev{
			return false;
		}
		prev = curr;
		n/=10;
	}
	return adj;
}

func process(curr int, buffer [6]int) int{
	if curr >= 6{
		var num = 0;
		for _, x := range buffer{
			num*=10;
			num+=x;
		}
		if num>=LOWER && num<=UPPER && isValid(num){
			return 1;
		}
		return 0;
	}
	var res = 0;
	var lower = 0;
	if curr-1>=0{
		lower = buffer[curr-1];
	}
	buffer[curr] = lower
	for buffer[curr] <= 9{
		res+=process(curr+1, buffer);
		buffer[curr]++;
	}
	return res;
}

func main(){
	fmt.Println(process(0, [6]int{0,0,0,0,0,0}));
}
{% endhighlight %}

<h2>Day 5</h2>
As I foreshadowed on Day 2, Day 5 was the day I was brought low. The problem was to implement additional addressing modes and operations to the intcode computer introduced in Day 2. In theory this should have been simple enough, the new operations could simply added into the main switch statement and a couple if statements should be a sufficient, if unwieldy, solution for addressing modes. What followed was a number of errors bought about by hasty and unwieldy design choices and misunderstanding of the problem task. First of all, wrapping each parameter in an if statement to handle the addressing modes proved to be much more unwieldly and repitious than expected, and in hindsight could've been very easily moved into a funtion. Next, my choice of handling for addressing modes also led me to apply my arithmetic operations in parts, first overwriting the target memory address and then adding/multiplying that memory address. This is a terrible idea, as many operations want to read from a memory location and write back to it afterwards, so overwriting it's value in the middle causes problems. Finally, my misunderstanding of the question lead me to waste time on an obviously wrong answer to try and work out the trick. The critical line in the problem statement was, "Non-zero outputs mean that a function is not working correctly; check the instructions that were run before the output instruction to see which one failed". When I read this I thought the problem was asking me to modify the instructs prior to the outputs to make them all 0, where actually an output of not all zeroes is just plane wrong. This was a great source of confusion for me for a while.

Against all odds, I managed to cobble together a passing solution. However, at this point it is abundantly clear that my first passing solution is sorely in need of refactoring. Here, for your viewing pleasure, are both versions of my solution.

{% highlight go %}
func main(){
	var scanner = bufio.NewScanner(os.Stdin);
	scanner.Scan();
	var input = scanner.Text();
	var codesText = strings.Split(input, ",");
	var codes []int;
	var output []int;
	for _, code := range codesText {
		x,  _ := strconv.Atoi(code);
		codes = append(codes, x);
	}
	//codes[1] = noun;
	//codes[2] = verb;
	step:= 0;
	for curr:=0; curr<len(codes); curr+=step{
		//fmt.Println(codes);
		opcode := codes[curr] % 100;
		param := codes[curr] / 100;
		//fmt.Print(codes[curr]);
		//fmt.Print(": ");
		switch(opcode){
			case 99:
				goto end;
			case 1:
				res:=0
				if param % 10 == 0{
					res = codes[codes[curr+1]];
					fmt.Printf("%d ", codes[codes[curr+1]]);
				} else {
					res = codes[curr+1];
					fmt.Printf("%d ", codes[curr+1]);
				}

				if (param/10) % 10 == 0{
					res += codes[codes[curr+2]];
					fmt.Printf("%d ", codes[codes[curr+2]]);
				} else {
					res += codes[curr+2];
					fmt.Printf("%d ", codes[curr+2]);
				}
				codes[codes[curr+3]] = res;
				step = 4;
			case 2:
				res:=0
				if param%10 == 0{
					res = codes[codes[curr+1]];
					fmt.Printf("%d ", codes[codes[curr+1]]);
				} else {
					res = codes[curr+1];
					fmt.Printf("%d ", codes[curr+1]);
				}

				if (param/10) %10 == 0{
					res *= codes[codes[curr+2]];
					fmt.Printf("%d ", codes[codes[curr+2]]);
				} else {
					res *= codes[curr+2];
					fmt.Printf("%d ", codes[curr+2]);
				}
				codes[codes[curr+3]] = res;
				step = 4;
			case 3:
				codes[codes[curr+1]] = 5;
				fmt.Printf("%d ", codes[curr+1]);
				step = 2;
			case 4:
				if param == 0 {
					output = append(output, codes[codes[curr+1]]);
					fmt.Printf("%d ", codes[codes[curr+1]]);
				} else {
					output = append(output, codes[curr+1]);
					fmt.Printf("%d ", codes[curr+1]);
				}
				step = 2;
			case 5:
				var cond bool;
				if param % 10 == 0{
					cond = codes[codes[curr+1]] != 0;
				} else {
					cond = codes[curr+1] != 0;
				}

				if cond {
					step = 0;
					if (param/10) % 10 == 0{
						curr = codes[codes[curr+2]];
					} else {
						curr = codes[curr+2];
					}
				} else {
					step = 3;
				}
			case 6:
				var cond bool;
				if param % 10 == 0{
					cond = codes[codes[curr+1]] == 0;
				} else {
					cond = codes[curr+1] == 0;
				}

				if cond {
					step = 0;
					if (param/10) % 10 == 0{
						curr = codes[codes[curr+2]];
					} else {
						curr = codes[curr+2];
					}
				} else {
					step = 3;
				}
			case 7:
				first := 0;
				second := 0;
				step = 4;
				if param % 10 == 0{
					first = codes[codes[curr+1]];
				} else {
					first = codes[curr+1];
				}

				if (param/10) % 10 == 0{
					second = codes[codes[curr+2]];
				} else {
					second = codes[curr+2];
				}

				if first < second {
					codes[codes[curr+3]] = 1;
				} else {
					codes[codes[curr+3]] = 0;
				}
			case 8:
				first := 0;
				second := 0;
				step = 4;
				if param % 10 == 0{
					first = codes[codes[curr+1]];
				} else {
					first = codes[curr+1];
				}

				if (param/10) % 10 == 0{
					second = codes[codes[curr+2]];
				} else {
					second = codes[curr+2];
				}

				if first == second {
					codes[codes[curr+3]] = 1;
				} else {
					codes[codes[curr+3]] = 0;
				}
		}
		//fmt.Println();
	}
	end:
	fmt.Println(codes);
	fmt.Println(output);
}
{% endhighlight %}

<h3>Day 6</h3>
Entering Day 6 I was slightly concerned as the word on the street seemed to be that this day was the great filter. That, in the past, Day 6 had been the difficulty break point that culled the weak once and for all. Todays problem was, given a tree representing planets and their orbits, calculate the total number of direct and indirect parent child relationships(orbits) in the tree, and the distance between two specific vertices. Being that the first five days of problems were more ad-hoc or mathematical, I can see why the shift to more traditional competitve programming problems would make a tonal shift for the competition as a whole. The kid gloves are coming off. The problem itself was fairly standard, first I ran a BFS through the tree starting from the root to calculate the depth of every vertex. Then, the total number of orbits is given sum of the depths of every vertex. Next to find the distance between two vertices we first find their lowest common ancestor, then the distance between them is given by the sum of the differences in level between the ancestor and the two vertices.

{% highlight go %}
type Node struct{
	children []*Node;
	parent *Node;
	level int;
};

func lowestCommonAncestor(a, b *Node) *Node{
	var parents = make(map[*Node]bool);
	for a != nil{
		parents[a] = true;
		a = a.parent;
	}
	for !parents[b]{
		b = b.parent;
	}
	return b;
}

func orbitalDistance(a, b, c *Node) int{
	return (a.parent.level-c.level)+(b.parent.level-c.level);
}

func main(){
	var ans = 0;
	var scn = bufio.NewScanner(os.Stdin);
	var star = make(map[string]*Node);
	for scn.Scan(){
		var input = strings.Split(scn.Text(), ")");
		if star[input[0]] == nil{
			var temp Node;
			star[input[0]] = &temp;
		}
		if star[input[1]] == nil{
			var temp Node;
			star[input[1]] = &temp;
		}
		star[input[0]].children = append(star[input[0]].children, star[input[1]]);
		star[input[1]].parent = star[input[0]];
	}
	var queue = []*Node{star["COM"]};
	queue[0].level = 0;
	queue[0].parent = nil;
	for len(queue) > 0{
		var curr = queue[0];
		ans+=curr.level;
		for _, node := range curr.children{
			node.level = curr.level+1;
			queue = append(queue, node);
		}
		queue = queue[1:];
	}
	fmt.Println(ans);
	fmt.Println(orbitalDistance(star["YOU"], star["SAN"], lowestCommonAncestor(star["YOU"], star["SAN"])));
}
{% endhighlight%}