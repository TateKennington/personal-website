---
layout: project
title: Advent of Code - 2020
description: A challenge to complete 25 algorithmic problems, one a day during the lead up to Christmas
thumbnail: /projects/thumbnails/aoc-2020.png
repo: https://github.com/TateKennington/AoC-2020
tags: Rust Competiton
date: 2020-02-20T10:20:00Z
---
Back again by popular demand is my analysis of last years Advent of Code problems. As part of a continuing tradition, as much as two times is a tradition, I used Advent of Code as an opportunity to build some familiarity with a new language. This years language was Rust, and while it's a language that I've been very keen on lately, it feels like it is very unsuited for competitive programming. Rust's iterators and more functional styled features were a real highlight of my experience, and I'm very glad that I have learned them, the focus on safety was a real speed bump in trying to solve problems quickly.

<h3>Day 1</h3>
In classic Advent of Code fashion the problems begin very gently. This days problem required you to find a pair, and then a triple in part 2, from a list of numbers whose sum is 2020. The obvious solution to this is to use nested loops to try each possible pair and triple until you find one that satisfies the condition. It is possible to do this slightly more effeciently by keeping a hash-set of numbers you've seen so far as you iterate over the list. Then when you consider a number you check if it's 2020 complement is in the set and break if it is. This way you can reduce the order of the algorithm by one polynomial degree, i.e part 1 to O(n) and part 2 to O(n^2). However, the naive brute force search is more than fast enough for size of the input set. This was a theme that I noticed alot this year, very few problems required you to push the performance far beyond the straight forward implementation. Even those larger problems could generally be brute forced with release mode optimisations in a few seconds.

<h3>Day 2</h3>
Day 2 was the beginning of the cruel and unusual input formats the plagued this year. It was not uncommon to see people complaining in Discord that they had spent significantly longer writing code to parse the problem input than to solve the problem. I was luckily able to afford most of this difficulty use Rust's Regex crate, along with the discovery of named capturing groups. As a side note I would strongly recommend named capturing groups to all frequent regex users, coming from Javascript regexes they have changed my life. The problem itself was to check the validity of a set of passwords according to a set of rules. In part one the rules related to how often a certain character is allowed to occur in the password, and in part two the rules indicate where in the password the character is allowed to occur. String processing is not something that is super natural or intuitive in Rust, but luckily the extensive iterator libraries meant the solution was relatively clean regardless. In particular, match and match_indices were the MVPs, with an honourable mention to fold.

<h3>Day 3</h3>
Day 3 was the first day which took an ascii art grid as input, a time honoured tradition. At this point in time, however, I was still struggling with the best way to read input in Rust. So far I only knew how to read input line by line rather than using the much more convenient read_to_string. This means that constructing the grid was slightly more awkward than it needed to be, but all in all was only a minor set back. This days problem required us to count how many "#"s were along a path with a certain slope, that wrapped around the width of the grid. The wrapping problem can be solved very neatly using modular arithmatic, then all that's left is to walk each line and count the "#"s. Part 2 just introduced more lines, so we only need to repeat the same proceedure more times. Although I didn't try to implement it, you could count all lines at once by iterating over each y coordinate and calculating the corresponding xs. This solution may be more "clever" but I'm not convinced it'll run much faster.

<h3>Day 4</h3>
This days problem was another string validation problem, but with passport fields as opposed to passwords. In particular we had to make sure certain fields were present in part 1, and that those fields had sensible values in part 2. I still hadn't cracked read_to_string yet, so recognising all the passport fields when they were spread across multiple lines was slightly challenging, but beyond that it was just a simple matter of splitting the fields into parts and writing regexes for the different fields. This problem was pretty disappointing, requiring alot of simple, tedious checking to solve, rather than any interesting algorithmic knowledge.

<h3>Day 5</h3>
Day 5 is a return to something a bit more algorithmic than Day 4. Here you had to work out the coordinates of a seat in a plane from a "binary" search description of it's location, for example "in the front half of the front half of the back half of the plane". Despite immediately making this connection I didn't realise until after that we could simply interpret the fronts and backs, and lefts and rights as binary to get the seats coordinates and instead calculated the bounds directly using a fold. I'm still pretty happy with how clean the fold turned out, using tuples to pass extra state between iterations in a fold was a trick I think I discovered doing these problems and is one I find very useful. Part 2 was just running part one multiple times and finding the missing seat, nothing too exciting here, just put all the seat numbers in a set, then iterate from the lowest seat number you've seen to the highest looking for the gap.

<h3>Day 6</h3>
We're back to a string processing problem on Day 6. In this case we are given a groups of peoples answer to a set of questions, each identified by a single letter, with one persons answers on each line. The task is to determine how many questions were answered by atleast one person in part 1, and by everyone in part 2. Again I still hadn't worked out how to read input and split it on a blank line yet, but otherwise the problem is just scanning each character and keeping a count of how many times that character has occured. Then you check the total number of characters scanned and the total number of characters that occurred the same number of times that there were people. Shoutout again to iterators and filter for making this second part very easy.

<h3>Day 7</h3>
It was at this point that I was starting to run up against my lack of knowledge in Rust. In particular implementing algorithms on trees, and graphs, basically non-linear data structures in general prove to be a point of contention as I keep working with Rust. This days problem was to analyse a tree of differently coloured bags containing some number of other differently coloured bags and work out how many of these bags ultimately contained a gold bag and then how many total bags a gold bag contained. To do the first part I flipped this tree so that the edges went from child bag to parent bag, that is a contained by relationship, and then did a BFS starting from the gold bag to work out how many bag colours contained gold, remembering to subtract one so we don't count gold itself. The next part of the problem, however, required me to also keep track of the tree in the traditional top down fashion, along with the weights of each edge, the multiplicity of each bag type. Once I had this structure I could just calculate the total number of bags contained within a bag by recursively calculating its children. All in all my implementation wasn't too bad, but I wish I could've simplified it a bit with structs and double linking for the trees instead of two big adjacency lists.

<h3>Day 8</h3>
Day 8 serves to further cement Advent of Codes tradition, for every year I've done it atleast, by having a problem based around some kind of virtual CPU. The first part of this problem was to detect when the CPU first loops, which only requires implementing the CPU and then simulating it while keeping track of which instructions you've visited. The second part is more interesting and involves finding which instruction you need to change in order to make the program terminate successfully. Again, and somewhat disappointingly, you can easily brute force this part but there is a fairly interesting linear time solution. The broad overview is to iterate over every index in the program and simulate starting from there, and mark each index you encounter as either looping or terminating depending on the result. If you encounter a known index you can mark each index up to that point as the same and continue. At the end of this we know whether a given index loops or terminates, and have only spent linear time, as each index in the program is only ever touched once. Then we can determine where to make the change by simulating the program again from the start, and at each index checking if making the change there would cause us to jump to a terminating index, again only taking linear time.

<h3>Day 9</h3>
This was the day that truly cemented my love of Rusts iterators, something which you may notice becoming a common theme throughout this write up. The problem in part one required you to look at a series of numbers and determine what number is the first one that couldn't be written as the sum of the 25 previous numbers, not counting the first 25 numbers. This is where the window iterator comes in, which gives us each subarray of a certain size, and find_map which allows us to map a function over the sub-array and returns the first non-none result. In this case the function we're using in find_map is the summand finding code from day 1. Then for part 2 we had to find a contiguous sub surray whose sum was the answer in part 1. I did this using a good old fashioned while loop with a sliding window. To sketch the algorithm we keep a start and end index and a running sum. While the running sum isn't the target sum, check if the running sum is less than the target, if so add one to the end index and add the number at the new index to the running sum, if it's less than the target subtract the number at the start index from the sum, and increment the start index. Shoutout to iterator min and max for making it easy to get the actual answer after finding the subarray from part 2.

<h3>Day 10</h3>
Day 10's problem was about the differences in a list of numbers. The first part was about computing how many numbers in the list differed by 1 and how many differed by 3. Again this part was easily dispatched by sorting the list and using window, with a size of 2. The second part required us to calculate how many subarrays there were such that no two adjacent numbers differed by more than 3. This is a classic one dimensional dynamic programming problem. This is because the total number of sub arrays that start from a given index is equal to the sum of sub arrays starting from greater indices whose values differ by no more than 3. I solved this using an interative approach starting from the end and working backwards, but you can probably solve it just as well with a top-down recursive approach if you use memoisation.

<h3>Day 11</h3>
Did anyone say cellular automata? Because Day 11's problem was cellular automata. Not too much to say about the implementation here, although I've found that as I do more of these it's alot easier to write a general check adjacent function that takes a direction than to write however many if statements you need to check all the adjacent cells. Which as I write it, sounds like a fairly obvious course of action. Part 2 changes the adjacency rules to be based on line of sight, which fits well with the separate check adjacent function methodology.

<h3>Day 12</h3>
Day 12 was a _cruisy_ day, not in the sense that it was easy, but in the sense that it was related to boat. The problem input was a series of compass directions and turns, part 1 just required you to simulate moving the boat according to these directions. Part 2 was where things got interesting as now some of the directions move a "waypoint" relative to the ship, and the "forward" direction move the ship to the waypoint. This would be entirely straight forward if the directions only included translations, however, there were also rotations of the waypoint about the ship to deal with. Ultimately, this only slightly complicated things, I chose to solve this by computing the transformation matrix for a rotation by 90 degrees in each direction, and then applied those multiple times to get my desired rotation. A nice benefit of doing it this way is we get to keep everything in integers, we don't need to bust out any trig functions or floating point numbers to compute rotations on the fly.

<h3>Day 13</h3>
All aboard the math bus for Day 13, a problem about buses and modular arithmetic. The problem input is a series of bus ids indicating how often they run in minutes and some "x"s, which won't be relevant until part 2, and a timestamp also in minutes. Part 1 tasks you with finding the first bus that runs after the given timestamp. You could probably brute force this part, but instead I took each bus id and subtracted from it the timestamp mod the bus id. This gives us how many minutes there are between the timestamp and the next bus running, and so the smallest of these gives us the answer to part 1. Part 2 is where the Chinese remainder theorem comes in, not that I knew that at the time, or really know that now as I have yet to do a deep dive into the theorem itself. In particular part 2 wants us to find a time where the sequence of buses arriving matches the input sequence, with the "x"s being wildcards. When I was doing this problem I heard alot of talk about solving the Chinese Remainder theorem using sieving, and if I had to put a name on my solution it would be sieving, so I may have just accidentally stumbled into a good algorithm. The vague idea is that I iterate over the timing sequence keeping a running product of all the bus ids encountered so far, and a current answer timestamp. For each id, I increase the answer timestamp by the running total until that id is arriving at the right point in the sequence, and then update the running product. Then once we have looped over all the bus ids our current answer timestamp is equal to the first time at which buses arrive in the correct sequence. The key piece of mathematical intuition that makes this work is that adding the running product to the current timestamp doesn't change the relative "positions" of the previous ids, that is they're all congruent to the same value, because the product is a multiple of all of the previous ids.

<h3>Day 14</h3>
Coming Soon?