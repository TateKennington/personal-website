---
layout: project
title: Advent of Code - 2020
description: A challenge to complete 25 algorithmic problems, one a day during the lead up to Christmas
thumbnail: /projects/thumbnails/aoc-2020.png
repo: https://github.com/TateKennington/AoC-2020
tags: Rust Competiton
date: 2020-02-20T10:20:00Z
---
Back again by popular demand is my analysis of last years Advent of Code problems. As part of a continuing tradition, as much as two times is a tradition, I used Advent of Code as an opportunity to build some familiarity with a new language. This years language was Rust, and while it's a language that I've been very keen on lately, it feels like it is very unsuited for competitive programming. Rust's iterators and more functional styled features were a real highlight of my experience, and I'm very glad that I have learned them, the focus on safety was a real speed bump in trying to solve problems quickly.

<h3>Day 1</h3>
In classic Advent of Code fashion the problems begin very gently. This days problem required you to find a pair, and then a triple in part 2, from a list of numbers whose sum is 2020. The obvious solution to this is to use nested loops to try each possible pair and triple until you find one that satisfies the condition. It is possible to do this slightly more effeciently by keeping a hash-set of numbers you've seen so far as you iterate over the list. Then when you consider a number you check if it's 2020 complement is in the set and break if it is. This way you can reduce the order of the algorithm by one polynomial degree, i.e part 1 to O(n) and part 2 to O(n^2). However, the naive brute force search is more than fast enough for size of the input set. This was a theme that I noticed alot this year, very few problems required you to push the performance far beyond the straight forward implementation. Even those larger problems could generally be brute forced with release mode optimisations in a few seconds.

<h3>Day 2</h3>
Day 2 was the beginning of the cruel and unusual input formats the plagued this year. It was not uncommon to see people complaining in Discord that they had spent significantly longer writing code to parse the problem input than to solve the problem. I was luckily able to afford most of this difficulty use Rust's Regex crate, along with the discovery of named capturing groups. As a side note I would strongly recommend named capturing groups to all frequent regex users, coming from Javascript regexes they have changed my life. The problem itself was to check the validity of a set of passwords according to a set of rules. In part one the rules related to how often a certain character is allowed to occur in the password, and in part two the rules indicate where in the password the character is allowed to occur. String processing is not something that is super natural or intuitive in Rust, but luckily the extensive iterator libraries meant the solution was relatively clean regardless. In particular, match and match_indices were the MVPs, with an honourable mention to fold.

<h3>Day 3</h3>
Day 3 was the first day which took an ascii art grid as input, a time honoured tradition. At this point in time, however, I was still struggling with the best way to read input in Rust. So far I only knew how to read input line by line rather than using the much more convenient read_to_string. This means that constructing the grid was slightly more awkward than it needed to be, but all in all was only a minor set back. This days problem required us to count how many "#"s were along a path with a certain slope, that wrapped around the width of the grid. The wrapping problem can be solved very neatly using modular arithmatic, then all that's left is to walk each line and count the "#"s. Part 2 just introduced more lines, so we only need to repeat the same proceedure more times. Although I didn't try to implement it, you could count all lines at once by iterating over each y coordinate and calculating the corresponding xs. This solution may be more "clever" but I'm not convinced it'll run much faster.

<h3>Day 4</h3>
This days problem was another string validation problem, but with passport fields as opposed to passwords. In particular we had to make sure certain fields were present in part 1, and that those fields had sensible values in part 2. I still hadn't cracked read_to_string yet, so recognising all the passport fields when they were spread across multiple lines was slightly challenging, but beyond that it was just a simple matter of splitting the fields into parts and writing regexes for the different fields. This problem was pretty disappointing, requiring alot of simple, tedious checking to solve, rather than any interesting algorithmic knowledge.

<h3>Day 5</h3>
Coming Soon?

<h3>Day 6</h3>
Coming Soon?

<h3>Day 7</h3>
Coming Soon?

<h3>Day 8</h3>
Coming Soon?

<h3>Day 9</h3>
Coming Soon?

<h3>Day 10</h3>
Coming Soon?

<h3>Day 11</h3>
Coming Soon?

<h3>Day 12</h3>
Coming Soon?

<h3>Day 13</h3>
Coming Soon?

<h3>Day 14</h3>
Coming Soon?